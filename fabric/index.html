<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js Fabric IK</title>
		<style>
			body {
				margin:0;
				font-family: 'verdana';
				font-size: 15px;
				line-height: 18px;
				overflow: hidden;
				background: #000;
			}

			canvas { width: 100%; height: 100% }

			#newWindow {
				display: block;
				position: absolute;
				bottom: 0.3em;
				left: 0.5em;
				color: #fff;
			}
		</style>
	</head>
	<body>

		<script src="js/three.min.js"></script>
		<script src='js/dat.gui.min.js'></script>
		<script src="js/OrbitControls.js"></script>

		<script src="js/fabik.min.js"></script>

		<script>

			var gui, scene, camera, renderer, orbit, ambientLight, lights, mesh, bones, skeletonHelper;

			var target, effector;

			var boxTarget , boxEffector;

			var box = [];

			var solver;

			var X_AXIS, Y_AXIS, Z_AXIS;
			var defaultBoneDirection, defaultBoneLength;


			function initScene () {

				gui = new dat.GUI();
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.z = 30;
				camera.position.y = 30;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				orbit = new THREE.OrbitControls( camera, renderer.domElement );
				orbit.enableZoom = false;



				boxTarget = new THREE.Mesh(new THREE.BoxBufferGeometry( 2, 2, 2 ),  new THREE.MeshStandardMaterial({color:0xFF0000}) );
				scene.add( boxTarget );
				boxTarget.position.set(0,20,0);
				target = boxTarget.position;

				ambientLight = new THREE.AmbientLight( 0x000000 );
				scene.add( ambientLight );

				lights = [];
				lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

				lights[ 0 ].position.set( 0, 200, 0 );
				lights[ 1 ].position.set( 100, 200, 100 );
				lights[ 2 ].position.set( - 100, - 200, - 100 );

				scene.add( lights[ 0 ] );
				scene.add( lights[ 1 ] );
				scene.add( lights[ 2 ] );

				window.addEventListener( 'resize', function () {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				}, false );


				//solver = new THREE.Fabric();

				//initBones();
				setupDatGui();

                X_AXIS = new Fabrik.V3( 1, 0, 0 );
                Y_AXIS = new Fabrik.V3( 0, 1, 0 );
                Z_AXIS = new Fabrik.V3( 0, 0, 1 );

                defaultBoneDirection = Z_AXIS.negated();
                defaultBoneLength = 10;

                solver = new Fabrik.Structure( scene );

                demo(0)

			}


			function setupDatGui () {

				gui.add( target, 'x', - 100, 100 ).onChange(function(value) {solver.update();});
				gui.add( target, 'y', - 100, 100 ).onChange(function(value) {solver.update();});
				gui.add( target, 'z', - 100, 100 ).onChange(function(value) {solver.update();});

	
			}

		
            function demo(n){

                

               // solver.clear();

                switch(n){
                    case 0:

                    for(var i=0; i< 20; i++){

                    var chain = new Fabrik.Chain();
                    var chain3D = [];

                    var startLoc = new Fabrik.V3(-40+(i*4),0,40);
                    var endLoc = startLoc.plus( defaultBoneDirection.times(defaultBoneLength));

                    var basebone = new Fabrik.Bone( startLoc, endLoc );
                    chain.addBone( basebone );

                    chain3D.push( addBone3D({ x:1, y:1, z:defaultBoneLength }, 0xFFFFFF) );

                    for (var j = 0; j < 7; j++) {

                        chain.addConsecutiveBone( defaultBoneDirection, defaultBoneLength );
                        chain3D.push( addBone3D() );

                    };

                    //console.log(chain3D)

                    solver.add( chain, chain3D, target );
                    }

                    break;
                }


                solver.update();
            }

            function addBone3D( size, color ){

                size = size || {x:1, y:1, z:defaultBoneLength }
                color = color || 0XFFFF00;
                var g = new THREE.BoxBufferGeometry( size.x, size.y, size.z );
                g.applyMatrix( new THREE.Matrix4().makeTranslation( size.x === 1 ? 0: size.x*0.5, size.y === 1 ? 0: size.y*0.5, size.z === 1 ? 0: size.z*0.5 ) )
                b = new THREE.Mesh( g,  new THREE.MeshStandardMaterial({color:color}) );
                scene.add( b );

                return b;
                
            }

			function render () {

				requestAnimationFrame( render );

                //solver.update();

				renderer.render( scene, camera );

			};

			//initTest();

			initScene();
			render();

		</script>
	</body>
</html>
