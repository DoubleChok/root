<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - sea3d / skin</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
body { margin: 0px; background-color: #000000; overflow: hidden; }
canvas { position: absolute; top:0; left:0; pointer-events:auto; width:100%; height:100%; }
		</style>
	</head>
	<body>
	<canvas id="canvas"></canvas>
		<script src="js/lib/three.min.js"></script>
		<script src="js/lib/OrbitControls.js"></script>
        <script src="js/lib/Stats.js"></script>
        <script src="js/lib/uil.min.js"></script>
		<script src="js/lib/sea3d.18.min.js"></script>

		<script>

			var container, canvas;

			var avatars = [];

			var walking = false;

			var camera, scene, renderer, controls, player, textureLoader, clock, stats;

			var mat;

			var man;
			var woman

            var model;

            var ui;

			var loader;

            var torad = 0.0174532925199432957;
            var env = 'plastic';


            var targets = {
                'dex' : 0,
                'herc' : 0,
                'marv' : 0,
                'fred' : 0,
                'jill' : 0,
                'tina' : 0,
                'stella' : 0
            };

            var TargetSkel = {
                'dex' : [
                    { x:1, y:1.3, z:1 }, // s0
                    { x:1.5, y:1.3, z:1 }, // s1
                    { x:2, y:1.3, z:1 }, // s2

                    { x:2, y:1, z:1 }, // clavicle
                    { x:1.1, y:1, z:1 }, // arm
                    { x:1.1, y:1.1, z:1.1 }, // hand

                    { x:1.1, y:0.9, z:1.1 }, // leg
                    { x:1, y:1, z:0.9 } // foot
                ],
                'herc' : [
                    { x:1, y:1.15, z:1 }, // s0
                    { x:1.75, y:1.2, z:1 }, // s1
                    { x:1.75, y:1.25, z:1 }, // s2

                    { x:2.5, y:1, z:1 }, // clavicle
                    { x:1.1, y:1, z:1 }, // arm
                    { x:1.1, y:1.1, z:1.1 }, // hand

                    { x:1.1, y:0.9, z:1.1 }, // leg
                    { x:1, y:1, z:0.9 } // foot
                ],
                'marv' : [
                    { x:1, y:1.15, z:1 }, // s0
                    { x:1.5, y:1.2, z:1 }, // s1
                    { x:1.25, y:1.25, z:1 }, // s2

                    { x:2.5, y:1, z:1 }, // clavicle
                    { x:1.1, y:1, z:1 }, // arm
                    { x:1.1, y:1.1, z:1.1 }, // hand

                    { x:1.1, y:0.9, z:1.1 }, // leg
                    { x:1, y:1, z:0.9 } // foot
                ],
                'fred' : [
                    { x:1, y:1.2, z:1 }, // s0
                    { x:1, y:1.2, z:1 }, // s1
                    { x:0.8, y:1.2, z:1 }, // s2

                    { x:0.8, y:1, z:1 }, // clavicle
                    { x:1, y:1, z:1 }, // arm
                    { x:1, y:1, z:1 }, // hand

                    { x:1, y:1, z:1 }, // leg
                    { x:1, y:1, z:1.2 } // foot
                ],
                'jill' : [
                    { x:1, y:0.9, z:1 }, // s0
                    { x:0.9, y:0.9, z:1 }, // s1
                    { x:0.8, y:0.9, z:1 }, // s2

                    { x:0.8, y:1, z:1 }, // clavicle
                    { x:0.9, y:1, z:1 }, // arm
                    { x:0.8, y:0.8, z:0.8 }, // hand

                    { x:1, y:0.9, z:1 }, // leg
                    { x:1, y:1, z:0.8 } // foot
                ],
                'tina' : [
                    { x:1, y:1, z:1 }, // s0
                    { x:0.9, y:0.9, z:1 }, // s1
                    { x:0.8, y:0.9, z:1 }, // s2

                    { x:0.8, y:1, z:1 }, // clavicle
                    { x:0.9, y:1, z:1 }, // arm
                    { x:0.8, y:0.8, z:0.8 }, // hand

                    { x:1, y:0.9, z:1 }, // leg
                    { x:1, y:1, z:1 } // foot
                ],
                'stella' : [
                    { x:1, y:0.9, z:1 }, // s0
                    { x:1.15, y:0.9, z:1 }, // s1
                    { x:1.15, y:0.9, z:1 }, // s2

                    { x:1.5, y:1, z:1 }, // clavicle
                    { x:0.8, y:1, z:1 }, // arm
                    { x:0.8, y:0.8, z:0.8 }, // hand

                    { x:1, y:0.9, z:1 }, // leg
                    { x:1, y:1, z:1 } // foot
                ],
            };

			// Initialize Three.JS

			init();
            animate();

			//

			function init() {



                clock = new THREE.Clock()

				canvas = document.getElementById( 'canvas' );

				textureLoader = new THREE.TextureLoader();


				mat = new THREE.MeshStandardMaterial({ skinning:true,  morphTargets:true, metalness:1, roughness:0.6, side:THREE.DoubleSide });

                //mat = new THREE.MeshBasicMaterial({ side:THREE.DoubleSide });

				textureLoader.load( env +'.jpg', textureComplete );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.set( 0, 10, -50 );

				controls = new THREE.OrbitControls( camera, canvas );
                controls.target.set( 0, 10, 0 );
                controls.update();

				renderer = new THREE.WebGLRenderer({ canvas:canvas, antialias:true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x333333, 1 );

				// extra lights

				var pointLight = new THREE.PointLight( 0xffffff, 2 );
				scene.add( pointLight );

				pointLight.position.set( 200, 300, -100 );

				scene.add( new THREE.AmbientLight( 0x888888 ) );


                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild( stats.domElement );


                initGui();


				// events

				window.addEventListener( 'resize', onWindowResize, false );


                load();



			}



            function initGui () {

                ui = new UIL.Gui({size:250, color:'no', height:16 });

                for(var t in targets){
                    ui.add( targets, t, { min:0, max:1, stype:2, precision:2 } ).onChange( applyMorph );
                }

            }

            function applyMorph () {

                for(var t in targets){
                    if(targets[t]) model.setWeight( t, targets[t] );
                }

                model.skeletonScallingAll();

            }

            function lerp(a, b, percent) { return a + (b - a) * percent; };
            function randRange(min, max) { return lerp( min, max, Math.random()); };
            function randRangeInt(min, max, n) { return lerp( min, max, Math.random()).toFixed(n || 0)*1; };

            function load() {

                //
                // SEA3D Loader
                //

                loader = new THREE.SEA3D();

                loader.onComplete = function( e ) {

                    var meshs = loader.meshes


                    model = meshs[0];
                    model.scale.multiplyScalar(0.1);
                    model.position.multiplyScalar(0.1);

                    model.material = mat;

                    scene.add( model );

                    model.play('walk');


                };

                //loader.load( 'models/avatar.tjs.sea' );
                loader.load( 'heroW.tjs.sea' );
                //loader.load( 'heroX.sea' );
                //loader.load( 'hero2.sea' )

            };

			function textureComplete( tex ){

				var name = tex.image.currentSrc.substring(tex.image.currentSrc.lastIndexOf('/')+1, tex.image.currentSrc.lastIndexOf('.'));
                tex.name = name;
                if(name === 'UV_Grid_Sm'){
                    tex.flipY = false
                    //mat.map = tex; 
                }
                if(name === env){ 
			        tex.mapping = THREE.SphericalReflectionMapping;
			        mat.envMap = tex;
			        mat.needsUpdate = true;

                    
			    }

			}

			function onWindowResize() {

                renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				
			};

			function animate() {

				var delta = clock.getDelta();

				requestAnimationFrame( animate );

                //THREE.SEA3D.AnimationHandler.update( delta )

                // Update SEA3D Animations
                THREE.SEA3D.AnimationHandler.update( delta*0.26 );

                // Update Three.JS Animations
              //  THREE.AnimationHandler.update( delta*0.6 );

				renderer.render( scene, camera );

                stats.update();

			};

//-----------------------
// SEA3D hack
//----------------------- 

THREE.SEA3D.SkinnedMesh.prototype.skeletonScallingAll = function() {

    var i, v, val;

    var result = [
        { x:1, y:1, z:1 }, // s0
        { x:1, y:1, z:1 }, // s1
        { x:1, y:1, z:1 }, // s2

        { x:1, y:1, z:1 }, // clavicle
        { x:1, y:1, z:1 }, // arm
        { x:1, y:1, z:1 }, // hand

        { x:1, y:1, z:1 }, // leg
        { x:1, y:1, z:1 }  // foot
    ];

    for(var t in targets){

        i = result.length;
        while(i--){

            v = TargetSkel[t][i];
            val = targets[t];

            result[i].x += (v.x - 1) * val;
            result[i].y += (v.y - 1) * val;
            result[i].z += (v.z - 1) * val;

        }
    }

    var bones = this.skeleton.bones;
    i = bones.length, name;

    while(i--){

        name = bones[i].name.substring(2, 8);

        if(!bones[i].scalling) bones[i].scalling = new THREE.Vector3(1,1,1);


        
        if( name === 'spine0' ) bones[i].scalling.copy( result[0] );
        if( name === 'spine1' ) bones[i].scalling.copy( result[1] );
        if( name === 'spine2' ) bones[i].scalling.copy( result[2] );
        
        // clavicle
        if( name === 'clavic' ) bones[i].scalling.copy( result[3] );
        // arm 
        if( name === 'forear' || name === 'upperA' ) bones[i].scalling.copy( result[4] );
        // hand
        if( name === 'finger' || name === 'hand' )  bones[i].scalling.copy( result[5] );

        // leg
        if( name === 'calf' || name === 'thigh' ) bones[i].scalling.copy( result[6] );
        // foot
        if( name === 'foot' || name === 'toe' ) bones[i].scalling.copy( result[7] );

        //

        // head
        //if( target[8] ) if( name === 'head' ) bones[i].scalling.lerp( target[8], val );

        // neck
        //if( target[9] ) if( name === 'neck' ) bones[i].scalling.lerp( target[9], val );

        // pelvis
        //if( target[10] ) if( name === 'pelvis' ) bones[i].scalling.lerp( target[10], val );

    }

}

//-----------------------
// force local scalling
//-----------------------

THREE.Skeleton.prototype.update = ( function () {

    var offsetMatrix = new THREE.Matrix4();
    var scaleMatrix = new THREE.Matrix4();
    var pos = new THREE.Vector3();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld: this.identityMatrix;

            // extra scalling vector

            if( this.bones[ b ].scalling && !this.isClone ){ 

                matrix.scale( this.bones[ b ].scalling );

                // update position of children

                for ( var i = 0, l = this.bones[ b ].children.length; i < l; i ++ ) {

                    scaleMatrix = matrix.clone();
                    scaleMatrix.multiply(this.bones[ b ].children[ i ].matrix.clone() );
                    pos.setFromMatrixPosition( scaleMatrix );
                    this.bones[ b ].children[ i ].matrixWorld.setPosition(pos);

                }

            }
            
            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            // only for three dev
            offsetMatrix.toArray( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

</script>
</body>
</html>
